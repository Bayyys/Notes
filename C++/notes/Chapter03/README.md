# 第三章 数据处理
### 👉【[复习题](./复习题.md)】【[编程练习题](./编程题.md)】
# 1. 简单变量

程序必须记录3个基本属性
- 信息将存储在哪里
- 要存储什么值
- 存储何种类型的信息

## 1.1 变量名
C++变量命名规则
- 变量名只能使用`字母字符`、`数字`和`下划线（_）`。
- 名称的`第一个`字符不能是`数字`。
- 区分大小写
- ~~不能将关键字用作名称~~
- 以`两个下划线`或`下划线`和`大写字母开头`的名称被保留给`实现（编译器及其使用的资源）`使用。以一个下划线开头的名称被保留给实现，用作`全局标识符`。
- 对名称长度没有限制，名称中所有字符都有意义。

> ✅ 小Tips: 变量名建议使用 `驼峰式` 的格式。例如：myEyeTooth 或 my_eyes。

## 1.2 整型
整数：没有小数部分的数字。如：77、-120等。

C++中，不同的整型使用不同的内存量，使用的内存越大，可表示的数值范围越大。

整型分为：
- 正值
- 负值

| 数据类型            | 占用空间                                        | 取值范围         |
| ------------------- | ----------------------------------------------- | ---------------- |
| short(短整型)       | 2字节                                           | (-2^15 ~ 2^15-1) |
| int(整型)           | 4字节                                           | (-2^31 ~ 2^31-1) |
| long(长整形)        | Windows为4字节，Linux为4字节(32位)，8字节(64位) | (-2^31 ~ 2^31-1) |
| long long(长长整形) | 8字节                                           | (-2^63 ~ 2^63-1) |

## 1.3 整型short、int、long和long long

计算机内存的基本单元：**位（bit）** 。

**字节（byte）** 通常是8位的内存单元。字节指的是描述计算机计算机内存量的度量单位。

单位换算：
```cpp
1 KB = 1024 byte
1 MB = 1024 KB
```

在C++种也确保了类型的最小长度
- short **至少** 16位
- int **至少**和 short一样长
- long**至少**32位，且**至少**与int一样长
- long long **至少** 64位，且**至少**与long一样长。

要知道系统中整数的最大长度，可以使用C++工具来检查类型的长度。

首先使用sizeof运算符返回类型或变量的长度，单位为字节。

climits中包含符号常量（预处理方式）来表示类型的限制。
```cpp
#include<iostream>
#include<climits> // 定义了符号常量来表示类型的限制
using namespace std;

int main()
{
    // 变量的初始化
    int n_int = INT_MAX;
    short n_short = SHRT_MAX;
    long n_long = LONG_MAX;
    long long n_llong = LONG_MAX;
    /**使用sizeof()运算符, 不是函数
     * 
     * 可对类型名（如int）或者是变量名（如n_short）使用，对变量名使用时，括号可有可无。
     */
    cout<<"int 是 "<<sizeof(int)<<" bytes "<<endl;
    cout<<"short 是 "<<sizeof n_short<<" bytes "<<endl;
    cout<<"long 是 "<<sizeof n_long<<" bytes "<<endl;
    cout<<"long long 是 "<<sizeof n_llong<<" bytes "<<endl;
    
    // 最大值
    cout<<"MAXIMUM Values:"<<endl;
    cout<<"int : "<<n_int<<endl;
    cout<<"short : "<<n_short<<endl;
    cout<<"long : "<<n_long<<endl;
    cout<<"long long : "<<n_llong<<endl;

    // 最小值
    cout<<"MINIMUM int value = "<<INT_MIN<<endl;
    cout<<"Bits per byte = "<<CHAR_BIT<<endl;

    return 0;
}

```
## 1.4 变量初始化问题
- 初始化将赋值和声明合并在一起。也可以使用**字面值常量**来初始化。也可以直接使用**表达式**来初始化变量。
```cpp
int variable00 = value;
int variable01 = value1 + value2;
int variable02(4);
```

- 如果不对函数内部定义的变量进行初始化，该变量的值不确定的。

- 将**大括号**初始化用于单值变量。
```cpp
int emus{7};
int rheas{12};
int var = {12};
```
> 大括号初始化器可用于任何类型（可以使用等号，也可以不使用），属于通用的初始化语法。
- 在大括号内也不包含任何东西。此时变量**初始化为零**。

- 变量的初始化的问题，有助于防范类型转换错误。

## 1.5 无符号类型
优点：可以增大变量能够存储的最大值。

创建无符号类型的变量时，只需要使用unsigned来进行声明即可。
> short变量加unsigned和没有unsigned，两者显示结果都是不一样的。
```cpp
unsigned int un_int = 100;
unsigned short u_sint = SHRT_MAX;
```

## 1.6 整型字面值
整型字面值（常量）：显式书写的常量。如777或者是222。

C / C++中的三种计数方法：
- 十进制（第一位为1～9，基数为10）----> dec
- 八进制（第一位为0，基数为8） ----> oct
- 十六进制（前两位以0x或0X开头，基数为16，0～9和a～f（A～F）的组合）----> hex
> 默认情况下，cout以`十进制形式`显示整数。

## 1.7 char类型
### 1.7.1 字符和小整数

char类型：专门存储**字符（如字母和数字）**，也是另外一种整型。

一般不超过128个字符，可以表示计算机系统中的所有基本符号 —> 所有的字母、数字和标点符号等。

**ASCII字符集**中的字符用数值编码**（ASCII码）**进行表示。如字符A的编码为65。

 ```cpp
#include <iostream>
int main(void)
{
    char ch = 'M';
    std::cout <<"The ASCII code for "<< ch <<" is "<<int(ch)<<std::endl;
    std::cout.put(ch); /* . 句点被称为成员运算符*/
    std::cout << std::endl;
    return 0;
}
 ```
### 1.7.2 成员函数cout.put() 

> C++ OOP概念中的成员函数
>
> 类定义了如何表示和控制数据。成员函数归类所有，描述了操作数据的方法。、

- `cout.put()` 提供了另一种显示字符的方法，可以替代 `<<` 运算符

> 在C++的 Release 2.0 之前，`cout`将字符变量显示为字符，而将字符常量（如 ‘M' 和 'N'）显示为数字。

### 1.7.3 char字面值

有些字符无法通过键盘输入到程序中，所以C++提供了特殊的表示方法 ----> `转义序列`。常见的如下

![C++转义序列的编码](https://s2.loli.net/2023/07/11/yWPs4MAN7RDUlgI.png)

> ✅ 小Tips:在可使用数字转义序列或符号转义序列（如\0x8和\b）时，应使用符号序列。
>
> 数字表示与特定的编码方式（如ASCII码）相关，而符号表示适用于任何编码方式，其可读性也更强。

<u> 将转义序列作为字符常量时，使用单引号，如果放在字符串时，则使用双引号</u>

```cpp
cout << endl; /* 使用endl重起一行 */
cout <<'\n'; /* 字符串常量 */
cout <<"\n"; /* 字符串 */
```

### 1.7.4 通用字符名

> C++ 实现只吃一个基本的源字符集，即可用来编写源代码的字符集。
>
> C++标准还允许实现提供扩展源字符集和扩展执行字符集。另外，那些被作为字母的额外字符也可用于标志符名称中。
>
> - C++用于表示这种特殊字符的机制，可独立于任何特定的键盘，即：通用字符名（universal character name）

- 通用字符名的用法类似于转义字符

  - 可以以 `\u` (后面是8个十六进制位)或 `\U` (后面是16个十六进制位)打头

  - 些位表示的是字符的ISO 10646码点

    > ISO 10646是一种正在制定的国际标准，为大量的字符提供了数值编码

### 1.7.5 符号问题

`char` 在默认情况下既不是没有符号，也不是有符号

- 是否有符号由C++实现决定

```c++
// 可以显式地设置类型
char fodo;
unsigned char bar;
signed char snark;
```

### 1.7.6 wchar_t

- 处理大型字符集

  1. 如果大型字符集是实现的基本字符集，编译器厂商可以将char定义为一个16为的字节或更长的字节
  2. 一种实现可以同时支持一个小型基本字符集和一个较大的扩展字符集

- wchar_t（宽字符类型）

  - `wchar_t` 是一种整数类型，可以表示系统使用的最大扩展字符集

  - `iostream` 头文件的最新版本提供了处理`wchar_t` 的工具——`wcin`和`wcout`

  - ```c++
    wchar_t bob = L'P'	// 可以通过加上前缀L来知识宽字符常量和宽字符串
    wcout << L"tall" << endl;	// 输出一个宽字符串
    ```

> :point_right:在进行国际编程或使用`Unicode`或`ISO 10646`时，应使用此变量名

### 1.7.7 C++11新增的类型

- `char16_t` 和 `char32_t`
  - 无符号，长度分别为16位、32位

`````c++
char16_t ch1 = u'q';	// 前缀u表示char16_t字符常量和字符串常量
char32_t ch2 = U'/U0000222B'	// 前缀U表示char32q_t字符常量和字符串常量
`````

> 有底层类型——一种内置的整型，但底层类型可能随系统而异

## 1.8 Bool类型

来源于数学表示法。

- C++将`非零值`表示为`true`，将`零`表示为`false`。

```cpp
bool is_ready = true;
```

# 2. const限定符

- 符号名称指出了常量表示的内容。

  - `const`关键字来修改变量声明和初始化。常量被初始化后，其值就被固定，编译器将不允许再修改该常量的值。

  - 将名称的`首字母大写`，以便提醒是个常量，可便于阅读性增强。
  - 如果是变量名全大写，则使用 `#define` 。

创建常量的通用格式为：
```cpp
const type name = value;
```

例如：
```cpp
const int Months = 12; // 一年有12个月
```
- 如果在声明const常量时没有提供值，该常量的值将是不确定，且无法更改。

> - 应使用`const`限定符，而不是类似C语言的`#define`
> - 在C++中可以用 `const` 值来声明数组长度

# 3. 浮点数
> 浮点数就是表示小数点部分的数字
>
> 计算机将值分为两部分存储：
>
> 1. 一部分表示值
> 2. 另一部分则用于对值进行放大或缩小

| **数据类型** | **占用空间** | **有效数字范围** |
| ------------ | ------------ | ---------------- |
| float        | 4字节        | 7位有效数字      |
| double       | 8字节        | 15～16位有效数字 |

## 3.1 为什么叫浮点数？

因为小数点可移动，所以称之为`“浮点数”`。

表示方法：

### 3.1.1 标准小数点表示法
```c++
3.14159
10.0
```

#### 3.1.2 E表示法（科学计数法）
例如：
```c++
3.45E6 // 3.45与10的6次方相乘，E6代表的是10的6次方。
```

E适合表示`非常大`和`非常小`的数。

![E表示法](https://s2.loli.net/2023/07/11/7mqTXAWEjpZHvix.png)

E表示法确保数字以浮点格式存储，即使没有小数点。

指数为负数意味着除以10的乘方，而不是乘以10的乘方。

8.33E-4表示:8.33 / 10的4次方,也就是：0.000833

> **技巧**：
>
> - d.dddE+n ———— 将小数点向右边移动n位
>
> - d.dddE-n ———— 将小数点向左边移动n位

## 3.2 浮点数类型

根据可以表示的`有效数位`和`允许的指数最小范围`，可以分为3种浮点数类型：`float`、 `double`和`long double`。

> 程序输出浮点数使用定点表示法
>
> ```c++
> cout.setf(ios_base::fixed, ios_base::floatfield);	// 定点表示
> ```

## 3.3 浮点常量

在书写浮点常量的时候，加 `后缀f/F、l/L` ， 以便区分何种类型，从而确定可表示的数值范围。例如：
```cpp
3.14f // float类型
3.14L // 长浮点型long double
```
## 3.4 浮点数优缺点
两个优点：
- 表示整数之间的值
- 有缩放因子

缺点：

- 运算速度慢
- 精度降低

<table border="1">
    <caption></caption>
  <tr>
    <td>100</td>
    <td>200</td>
    <td>300</td>
  </tr>
  <tr>
    <td>400</td>
    <td>500</td>
    <td>600</td>
  </tr>
</table>

# 4. C++算术运算符
五种基本运算符进行基本的算术运算。

`加（+）、减（-）、乘（*）、除（/）、求模（%）`


运算符的优先级和数学中的优先级类似。

## 4.1 除法运算符问题的总结
除法运算符（/）的行为取决于操作数的类型。

如果两个操作数都是整数，则C++将执行整数除法。把结果的小数部分丢弃，使最后的一个结果是一个整数。

如果其中有一个（或两个）操作数是浮点数，则小数部分将保留，结果为浮点数。 

```cpp
#include<iostream>
using namespace std;

int main()
{
    // 如果编译器不接受self()中的ios_base,请使用ios。   
    cout.setf(ios_base::fixed,ios_base::floatfield);
    cout<<"整数消除： 10 / 5 = "<<10/5<<endl; /*输出结果：10 / 5 = 2*/
    cout<<"浮点数消除：10.0 / 5.0 = "<<10.0/5.0<<endl; /*输出结果：10.0 / 5.0 = 2.000000*/
    cout<<"浮点数消除：10.0 / 5 = "<<10.0/5<<endl; /*输出结果：10.0 / 5 = 2.000000*/
    cout<<"double常量：1.e7 / 9.0 = "<<1.e7 / 9.0<<endl; /*输出结果：1.e7 / 9.0 = 1111111.111111*/
    cout<<"浮点常量：1e7f / 9.0f = "<<1.e7f / 9.0f<<endl; /*输出结果：1e7f / 9.0f = 1111111.125000*/
    return 0;
}
```
运算符重载：使用相同的符号进行多种操作。


## 4.2 求模运算符
求模（求余）：返回`整数除法`的余数。

与整数除法结合，适用于解决要求讲一个量分成的整数单元的问题

⚠️注意：浮点数 ~~没有求模运算~~。

## 4.3 类型转换
### 4.3.1 类型转换的规则

- 将一种算术类型的值赋给另一种算术类型的变量时，C++对值转换为接收变量的类型。
- 表达式中包含不同的类型时，C++对值进行转换
- 将参数传递给函数时，由函数原型控制，C++对值进行转换

数值转换中存在的潜在问题

![潜在的数值转换问题](D:/Coding/test/temp/C++/notes/Chapter03/img/%E6%BD%9C%E5%9C%A8%E7%9A%84%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98.png)

### 4.3.2 类型的强制转换

- **强制转换本身不会修改变量本身，而是创建一个新的、指定类型的值**。

### 4.3.3 强制转换的通用格式如下：

```cpp
(typename) value //来源于C语言
typename (value) // C++
```

## 4.4 C++11中的`auto`声明
在初始化声明中，如果使用`关键字auto` 时，而`不指定变量的类型`，编译器将把变量的类型设置成与初始值相同。
```cpp
auto n = 100; /*自动设置为int类型*/
auto x = 1.15; /*自动设置为double类型*/
```

> 处理复杂类型，如标准模块库（STL）中的类型时，自动类型推断有事才能显现出来
>
> ```c++
> std::vector<double> scores;
> std::vector<double>::iterator pv = scores.begin();
> 
> /* C++11允许将其重写为如下形式 */
> std::vector<double> scores;
> auto pv = scores.begin();
> ```
>
> 
